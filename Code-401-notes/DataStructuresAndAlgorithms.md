## Watch

### Basic Recursion

(source: <https://www.youtube.com/watch?v=vPEJSJMg4jY>)

- Recursion - when a function calls itself
- if written incorrectly can create infinite loop
- two parts - Base Case and Recursive Case
  - Recursive case - when the function calls itself
  - Base case - when the function does not call itself again

### Data Structures in 15 Minutes

(source: <https://www.youtube.com/watch?v=sVxBVvlnJsM>)

- Big O notation - measure of how well an operation scales (efficiency)
- 5 most important data structures
  - Linked Lists - good at adding and deleting nodes, not good at retrieval or searching
  - Array
  - Hash Table - Key/ value pairs
  - Stack + Queue - (stack is Last in First Out) (Queue is First in First out)
  - Graphs + Trees -

### Big O Explained

(source: <https://www.youtube.com/watch?v=v4cd1O4zkGw>)

- How time scales with respect to some input variables
- O of 1 - constant time, doesn't take longer with more input (carrier pigeon/USB)
- O of n - scales linearly with the amount of input
- 4 important rules to know about Big O
  - if you have two different steps in algorithm, you add up those steps
  - drop constants
  - if different inputs, use different variables to represent them
  - drop non-dominant terms

## Read

### Basic Data Structures

(source: <https://towardsdatascience.com/8-common-data-structures-every-programmer-must-know-171acf6a1a42>)

- 8 common data structures to know
  - Arrays
  - Linked Lists
  - Stacks (Last in First Out)
  - Queues (First in First Out)
  - Hash Tables (Values have keys associated with them)
  - Trees
  - Heaps (special case of a binary tree where the parent nodes are compared to their children with their values and are arranged accordingly)
  - Graphs (finite set of vertices or nodes and a set of edges connecting these vertices)

### Why Big O

(Source: <https://triplebyte.com/blog/why-you-should-learn-big-o-and-stop-hacking-your-way-through-algorithms>)

- Big O is just a notation - "Math Speak"
- algorithms provide efficiency that is important for software dev
- Helps prevent mistakes in interviews ex: purpose of a BST is to achieve logarithmic search)

## Discussion Questions

- What is 1 of the more important things you should consider when deciding which data structure is best suited to solve a particular problem?
  - how you will be using the data, do you need to search quickly, or add/remove data quickly?
- How can we ensure that weâ€™ll avoid an infinite recursive call stack?
  - include a Base Case

## Things I Want to Know More About

- Wow, this is a lot to take in. I feel like I want to know more about basically all of it. But especially what Data Structures we are more likely going to be working with and how to "plan ahead" when writing our code to make that easier.
